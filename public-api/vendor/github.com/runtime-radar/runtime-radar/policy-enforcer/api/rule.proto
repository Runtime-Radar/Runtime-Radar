syntax = "proto3";

package rule;

import "google/api/annotations.proto";
import "protoc-gen-openapiv2/options/annotations.proto";
import "google/protobuf/empty.proto";

option go_package = "./api";
option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_swagger) = {
  info: {
    title: "Rule API";
    contact: {
    };
  };
};

// The RuleController service definition.
service RuleController {
    rpc Create(Rule) returns (CreateRuleResp) {
        option (google.api.http) = {
            post: "/api/v1/rule"
            body: "*"
        };
    }
    rpc Read(ReadRuleReq) returns (ReadRuleResp)  {
        option (google.api.http) = {
            get: "/api/v1/rule/{id}"
        };
    }
    rpc Update(Rule) returns (google.protobuf.Empty) {
        option (google.api.http) = {
            patch: "/api/v1/rule/{id}"
            body: "*"
        };
    }
    rpc Delete(DeleteRuleReq) returns (google.protobuf.Empty) {
        option (google.api.http) = {
            delete: "/api/v1/rule/{id}"
        };
    }

    rpc ListPage(ListRulePageReq) returns (ListRulePageResp) {
        option (google.api.http) = {
            get: "/api/v1/rule/page/{page_num}"
        };
    }

    // NotifyTargetsInUse returns true if at least one of given notification targets used by rule.
    // Method is not considering softly deleted rules.
    rpc NotifyTargetsInUse(NotifyTargetsInUseReq) returns (NotifyTargetsInUseResp) {
        option (google.api.http) = {
            get: "/api/v1/rule/notify-targets-in-use"
        };
    }
}

message Rule {
    enum Type {
        TYPE_RUNTIME = 0;
    }

    message Scope {
        string version = 1;
        repeated string image_names = 2;
        repeated string registries = 3;
        repeated string clusters = 4;
        repeated string namespaces = 5;
        repeated string pods = 6;
        repeated string containers = 7;
        repeated string nodes = 8;
    }

    string id = 1;
    string name = 2;

    message RuleJSON {
        string version = 1;

        message Block {
            string severity = 1;
        }
        Block block = 2;

        message Notify {
            string severity = 1;
            repeated string targets = 2;
        }
        Notify notify = 3;

        message Whitelist {
            reserved 1,2;
            repeated string threats = 3;
            repeated string binaries = 4;
        }
        Whitelist whitelist = 4;
    }

    RuleJSON rule = 3;
    reserved 4;
    // type indicates what type of enforcement rule is used for (now support just runtime.)
    Type type = 5;
    Scope scope = 6;
}

message CreateRuleResp {
    string id = 1;
}

message ReadRuleReq {
    string id = 1;
}

message ReadRuleResp {
    Rule rule = 1;
    bool deleted = 2;
}

message DeleteRuleReq {
    string id = 1;
}

message ListRulePageReq {
    uint32 page_num = 1;
    uint32 page_size = 2;
    string order = 3;
}

message ListRulePageResp {
    uint32 total = 1;
    repeated Rule rules = 2;
}

message NotifyTargetsInUseReq {
    repeated string targets = 1;
}

message NotifyTargetsInUseResp {
    bool in_use = 1;
}
